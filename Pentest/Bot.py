import telebot, os, random, vt

Token = '<tu token>'
vt_api_key = '<tu api_key>'
chat_id = '<tu chat_id>'


bot = telebot.TeleBot(Token)

# -------Bienvenida
print('bienve')

# Manejar el evento de nuevos miembros en un grupo
@bot.message_handler(func=lambda message: True, content_types=['new_chat_members'])
def welcome_message(message):
    welcome_messages = [
        f'¬°Bienvenid@ {message.from_user.first_name} a este grupo de hacking √©tico! Presentate, Hackea y pasalo genial.',
        f'¬°Hola {message.from_user.first_name}! Bienvenid@ a este grupo. Estas Hack?',
        f'¬°Saludos {message.from_user.first_name}! Bienvenid@ a √©sta comunidad de Cyber. Si tienes alguna pregunta √©tica, no dudes en hacerla.',
        f'{message.from_user.first_name}, s√© bienvenid@ al grupo m√°s hack, a disfrutar!']
    random_welcome = random.choice(welcome_messages)
    bot.reply_to(message, random_welcome)


# -------Comandos
print('coman')

@bot.message_handler(commands=['pentest'])  # --Llamada a bot
def init(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, si utilizas /help, podras ver los comandos que tengo disponibles.'.format(user_name))
    print('pingu')

@bot.message_handler(commands=['nmap'])  # --Listado de comandos nmap
def nmap(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, los comandos de nmap son los siguientes: \n \n -->Descubrir sistemas: \n -PS n tcp syn ping \n -PA n ping TCP ACK \n -PU n ping UDP \n -PM Netmask Req \n -PP Timestamp Req \n -PE Echo Req \n -sL an√°lisis de listado \n -PO ping por protocolo \n -PN No hacer ping \n -n no hacer DNS \n -R Resolver DNS en todos los sistemas objetivo \n ‚Äìtraceroute: trazar ruta al sistema (para topolog√≠as de red) \n -sP realizar ping, igual que con ‚ÄìPP ‚ÄìPM ‚ÄìPS443 ‚ÄìPA80 \n \n -->T√©cnicas de an√°lisis de puertos: \n -sS an√°lisis utilizando TCP SYN \n -sT an√°lisis utilizando TCP CONNECT \n -sU an√°lisis utilizando UDP \n -sY an√°lisis utilizando SCTP INIT \n -sZ utilizando COOKIE ECHO de SCTP \n -sO protocolo IP \n -sW ventana TCP -sN \n ‚ÄìsF -sX NULL, FIN, XMAS \n ‚ÄìsA TCP ACK \n \n -->Puertos a analizar y orden de an√°lisis: \n -p n-mrango \n -p‚Äì todos los puertos \n -p n,m,z especificados \n -p U:n-m,z T:n,m U para UDP, T para TCP \n  -F r√°pido, los 100 comunes \n ‚Äìtop-ports n analizar los puertos m√°s utilizados \n -r no aleatorio \n \n -->Duraci√≥n y ejecuci√≥n: \n -T0 paranoico \n -T1 sigiloso \n -T2 sofisticado \n -T3 normal \n -T4 agresivo \n -T5 locura \n ‚Äìmin-hostgroup \n ‚Äìmax-hostgroup \n ‚Äìmin-rate \n ‚Äìmax-rate \n ‚Äìmin-parallelism \n ‚Äìmax-parallelism \n ‚Äìmin-rtt-timeout \n ‚Äìmax-rtt-timeout \n ‚Äìinitial-rtt-timeout \n ‚Äìmax-retries \n ‚Äìhost-timeout ‚Äìscan-delay \n \n -->Detecci√≥n de servicios y versiones: \n -sV: detecci√≥n de la versi√≥n de servicios \n ‚Äìall-ports no excluir puertos \n ‚Äìversion-all probar cada exploraci√≥n \n ‚Äìversion-trace rastrear la actividad del an√°lisis de versi√≥n-O activar detecci√≥n del S. Operativo \n ‚Äìfuzzy adivinar detecci√≥n del SO \n ‚Äìmax-os-tries establecer n√∫mero m√°ximo de intentos contra el sistema objetivo \n \n -->Evasi√≥n de Firewalls/IDS: \n -f fragmentar paquetes \n -D d1,d2 encubrir an√°lisis con se√±uelos \n -S ip falsear direcci√≥n origen \n ‚Äìg source falsear puerto origen \n ‚Äìrandomize-hosts orden \n ‚Äìspoof-mac <mac> cambiar MAC de origen \n \n -->Par√°metros de nivel de detalle y depuraci√≥n: \n -v Incrementar el nivel de detalle \n ‚Äìreason motivos por sistema y puerto \n -d (1-9) establecer nivel de depuraci√≥n \n ‚Äìpacket-trace ruta de paquetes \n \n -->Otras opciones: \n ‚Äìresume file continuar an√°lisis abortado (tomando formatos de salida con -oN o -oG) \n -6 activar an√°lisis IPV6 \n -A agresivo, igual que con -O -sV -sC ‚Äìtraceroute \n \n -->Opciones interactivas: \n v/V aumentar/disminuir nivel de detalle del an√°lisis \n d/D aumentar/disminuir nivel de depuraci√≥n \n p/P activar/desactivar traza de paquetes \n \n -->Scripts: \n -sC realizar an√°lisis con los scripts por defecto \n ‚Äìscript file ejecutar script (o todos) \n ‚Äìscript-args n=v proporcionar argumentos \n ‚Äìscript-trace mostrar comunicaci√≥n entrante y saliente \n \n -->Formatos de salida: \n -oN guardar en formato normal \n -oX guardar en formato XML \n -oG guardar en formato para posteriormente usar Grep(una linea) \n -oA guardar en todos los formatos anteriores'.format(user_name))
    print('nmap')

@bot.message_handler(commands=['reverse'])   #--Reverse-Shell info
def reverse(message):
    print('reverse')
    try:
        # Construye la ruta del archivo .pdf independiente de la plataforma
        pdf_file_path = os.path.join(os.getcwd(), 'Pentest', 'Reverse_Shell.pdf')

        # Env√≠a el mensaje de texto como respuesta al comando
        user_name = message.from_user.first_name
        bot.reply_to(message, 'Hola {}, mis sugerencias para realizar una reverse shell las tienes en el siguiente enlace de GitHub o sino, puedes revisar el archivo .pdf que te env√≠o justo despues: \n'.format(user_name) + '\n' + 'https://github.com/0dayCTF/reverse-shell-generator')

        # Env√≠a el archivo .pdf al chat
        with open(pdf_file_path, 'rb') as pdf_file:
            bot.send_document(message.chat.id, pdf_file)

    except Exception as e:
        bot.reply_to(message, "Ha ocurrido un error al enviar el archivo. Por favor, int√©ntalo m√°s tarde.")
        print(f"Error: {e}")

# Manejador para el comando /puertos
@bot.message_handler(commands=['puertos'])
def puertos(message):
    print('puertos')
    try:
        # Construye la ruta del archivo .pdf independiente de la plataforma
        pdf_file_path = os.path.join(os.getcwd(), 'Pentest', 'Puertos_comunes.pdf')

        # Env√≠a el mensaje de texto como respuesta al comando
        user_name = message.from_user.first_name
        bot.reply_to(message, 'Hola {}, los puertos utilizados m√°s comunes, podr√°s verlos en el siguiente archivo .pdf: \n'.format(user_name))

        # Env√≠a el archivo .pdf al chat
        with open(pdf_file_path, 'rb') as pdf_file:
            bot.send_document(message.chat.id, pdf_file)

    except Exception as e:
        bot.reply_to(message, "Ha ocurrido un error al enviar el archivo. Por favor, int√©ntalo m√°s tarde.")
        print(f"Error: {e}")
    

@bot.message_handler(commands=['gobuster'])  
def gobuster(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, a enumerar un ratito?? \n'.format(user_name) + gob)
    print('gobuster')
gob = '''
        Gobuster es una herramienta de fuerza bruta muy potente y con el objetivo de enumerar uris en sitios web, es decir, directorios y ficheros, subdominios dns y nombres de host virtuales en servidores web.
        
        Para la enumeraci√≥n de subdominios dns utilizaremos la palabra clave dir, que como todo comando tiene su propia ayuda:
        
        Usage:
          gobuster dns [flags]
         
        Flags:
          -d, --domain string      The target domain
          -h, --help               help for dns
          -r, --resolver string    Use custom DNS server (format server.com or server.com:port)
          -c, --show-cname         Show CNAME records (cannot be used with '-i' option)
          -i, --show-ips           Show IP addresses
              --timeout duration   DNS resolver timeout (default 1s)
              --wildcard           Force continued operation when wildcard found
         
        Global Flags:
              --delay duration    Time each thread waits between requests (e.g. 1500ms)
              --no-error          Don't display errors
          -z, --no-progress       Don't display progress
          -o, --output string     Output file to write results to (defaults to stdout)
          -p, --pattern string    File containing replacement patterns
          -q, --quiet             Don't print the banner and other noise
          -t, --threads int       Number of concurrent threads (default 10)
          -v, --verbose           Verbose output (errors)
          -w, --wordlist string   Path to the wordlist
        
          Para la enumeraci√≥n de virtual hosts utilizaremos la palabra clave vhost, que como todo comando tiene su propia ayuda:
        
        Usage:
          gobuster vhost [flags]
         
        Flags:
          -c, --cookies string        Cookies to use for the requests
          -r, --follow-redirect       Follow redirects
          -H, --headers stringArray   Specify HTTP headers, -H 'Header1: val1' -H 'Header2: val2'
          -h, --help                  help for vhost
          -m, --method string         Use the following HTTP method (default "GET")
          -k, --no-tls-validation     Skip TLS certificate verification
          -P, --password string       Password for Basic Auth
              --proxy string          Proxy to use for requests [http(s)://host:port]
              --random-agent          Use a random User-Agent string
              --timeout duration      HTTP Timeout (default 10s)
          -u, --url string            The target URL
          -a, --useragent string      Set the User-Agent string (default "gobuster/3.1.0")
          -U, --username string       Username for Basic Auth
         
        Global Flags:
              --delay duration    Time each thread waits between requests (e.g. 1500ms)
              --no-error          Don't display errors
          -z, --no-progress       Don't display progress
          -o, --output string     Output file to write results to (defaults to stdout)
          -p, --pattern string    File containing replacement patterns
          -q, --quiet             Don't print the banner and other noise
          -t, --threads int       Number of concurrent threads (default 10)
          -v, --verbose           Verbose output (errors)
          -w, --wordlist string   Path to the wordlist
        
        Para la enumeraci√≥n de buckets S3 utilizaremos la palabra clave s3, que como todo comando tiene su propia ayuda:
         
        Usage:
          gobuster s3 [flags]
         
        Flags:
          -h, --help               help for s3
          -m, --maxfiles int       max files to list when listing buckets (only shown in verbose mode) (default 5)
              --proxy string       Proxy to use for requests [http(s)://host:port]
              --random-agent       Use a random User-Agent string
              --timeout duration   HTTP Timeout (default 10s)
          -a, --useragent string   Set the User-Agent string (default "gobuster/3.1.0")
         
        Global Flags:
              --delay duration    Time each thread waits between requests (e.g. 1500ms)
              --no-error          Don't display errors
          -z, --no-progress       Don't display progress
          -o, --output string     Output file to write results to (defaults to stdout)
          -p, --pattern string    File containing replacement patterns
          -q, --quiet             Don't print the banner and other noise
          -t, --threads int       Number of concurrent threads (default 10)
          -v, --verbose           Verbose output (errors)
          -w, --wordlist string   Path to the wordlist
'''

@bot.message_handler(commands=['sqlmap'])  
def sqlmap(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, su uso es --> \'python sqlmap.py [opciones]\' y las opciones te las dejo a continuaci√≥n: \n'.format(user_name) + '''
                --url  url  (-u) con la variable vulnerable ejemplo elhacker.net/noticia.php?id=1
                -p (buscar otra variable vunlerable) elhacker.net/noticia.php?id=1&user
                --data si hay un formulario GET,POST los campos vulnerables
                --level=n cinco niveles seg√∫n dificultad
                --dbs listar las bases de datos
                --dbms  motor de la base de datos (MySQL,SQL Server ,etc)
                 -D indicamos la base de datos a utilizar (-Database)
                 --tables mostrar las tablas disponibles 
                -t nombre de la tabla --columns
                --dump vuelca resultados, mostrar contenido de las tablas
                -C (Columnas) columnas a mostrar
                --wizard ejecuta un asistente
                 --threads=n n√∫mero de procesos (por defecto 1)
                --delay=n segundos de espera entre peticiones http
                --current-db base de datos que est√° usando actualmente
                --current-user ver usuario que est√° ejecutando
                --is-dba ‚Äìcurrent-db ver si el usuario es el dba de la BD
                --privileges ver los privilegios del usuario (alter, create, drop, execute)
                --file-read path (ruta) leer ficheros
                --sql-shell obtener una sql en shell
                --os-shell obtener shell en el servidor (asp es la 1, aspx 2, jsp 3, php 4) (si se poseen los suficientes privilegios y un FPD (Full Path Disclosure)
                 --headers= cabeceras del navegador
                --random-agent cabeceras del navegador aleatorias
                --time-sec= Segundos para retrasar la respuesta de DBMS (por defecto 5)
                ---technique= : Se utiliza para seleccionar la t√©cnica que se va a utilizar en la inyecci√≥n ( B - E - U - S - T - Q.) Boolean-based, Error-based, Union, Stacked querys, Time-based, Inline queries
                --flush-session
                - Si el SQLi es Blind Boolean Based , se especifica con una "B"
                - Si el SQLi es Error Based/Double Query , se especifica con una "E"
                - Si el SQLi es Union Based , se especifica con una "U"
                - Si el SQLi es Stacked querys , se especifica con una "S"
                - Si el SQLi es Time Based , se especifica con una "T"
                - Si el SQLi es Inline queries , se especifica con una "Q"
                --forms si queremos que busque autom√°ticamente los campos de formularios
                --proxy= usar servidor proxy 
                --sql-query a√±adir consulta sql
                --tamper= scripts ofuscaci√≥n y bypass (ejemplo space2mysqlblank.py, charencode.py, base64encode.py, randomcomments.py, etc)
                --chek-tor ---> User Tor Anonymity Network
                --tor-port ---> Set Tor proxy port other than default
                --tor-type ---> Set Tor proxy type (HTTP (default ), SOCKS4 or SOCKS5)
                Listado completo  en la documentaci√≥n oficial:
                 
                 https://github.com/sqlmapproject/sqlmap/wiki/Usage
                 
                 ''')
    print('sqlmap')

@bot.message_handler(commands=['nuclei'])  
def nuclei(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, a continuaci√≥n te dejo algo de info que espero te ayude: \n'.format(user_name) + nuclei)
    print('nuclei')
nuclei = '''
Nuclei es un esc√°ner de vulnerabilidades escrito en Go permitiendo realizar la detecci√≥n en diferentes protocolos, como por ejemplo; TCP, HTTP, DNS.

La primera vez que se ejecuta la herramienta, lo primero que hace es descargar las plantillas desarrolladas por la comunidad y almacenar dichos ficheros en $HOME/nuclei-templates. A partir de este punto, se puede lanzar la herramienta utilizando cualquiera de las plantillas ya existentes o con una nueva.


Hay varias opciones que son interesantes a la hora de ejecutar la herramienta y simplemente leyendo la ayuda se pueden entender f√°cilmente, sin embargo las m√°s importantes son las siguientes:

-target / -u: Permite indicar una URL sobre la que se van a realizar las pruebas.
-list / -l: Permite indicar un listado de objetivos en un fichero de texto, una URL por cada l√≠nea en el fichero.
-automatic-scan / -as: Ejecuta un escaneo autom√°tico utilizando Wappalyzer para la detecci√≥n de la arquitectura del objetivo.
-templates / -t: Listado de plantillas o de directorios que contienen plantillas separado por comas.
-tl: Simplemente lista todas las plantillas que detecta nuclei. Si se ejecuta la herramienta sin la opci√≥n ¬´-templates¬ª ense√±ar√° las plantillas de la comunidad que como se ha indicado antes, se encuentran en el directorio $HOME/nuclei-templates.
-validate: Valida las plantillas que se han enviado con la opci√≥n ¬´-templates¬ª para comprobar que los ficheros YAML se encuentran bien formados.
-et / -exclude-templates: Listado de plantillas o de directorios que contienen plantillas que debe ser ignorado por nuclei separado por comas.
-s / ‚Äìseverity: Indica que las plantillas deben ser ejecutadas en funci√≥n del campo ¬´severity¬ª de la plantilla, en donde los posibles valores pueden ser: info, low, medium, high, critical, unknown
-o / -output: Fichero de salida en donde se almacenan los problemas/vulnerabilidades descubiertos por la herramienta.
-sresp / -store-resp: Almacena todas las peticiones y respuestas que ha gestionado nuclei en el directorio indicado con la opci√≥n ¬´-output¬ª.
-silent: No ense√±a trazas, solamente los problemas descubiertos.
-config: Permite indicar un fichero de configuraci√≥n personalizado para modificar el comportamiento por defecto de la herramienta.
-update: Actualizar la herramienta
-up / -update-templates: Actualizar las plantillas de la comunidad a la versi√≥n m√°s reciente.
-duc / -disable-update-check: Por defecto Nuclei verifica si las plantillas locales se encuentran actualizadas, con esta opci√≥n se deshabilita este comportamiento.
'''

@bot.message_handler(commands=['metasploit'])  
def metasploit(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, a continuaci√≥n te dejo algo de info sobre Metasploit: \n'.format(user_name) + info)
    print('metasploit')
info = '''
       Metasploit consta de varias herramientas distintas:

       msfconsole. Consola de Metasploit.
       msfcli. Nos permite ejecutar m√≥dulos directamente sin entrar en la consola.
       msfpayload. Para generar payloads.
       msfencode. Permite codificar los payloads para quitar null bytes por ejemplo.
       msfvenom. Combinaci√≥n de msfpayload y msfencode en una sola herramienta.

       Los pasos b√°sicos a seguir para explotar vulnerabilidades usando Metasploit son:


       Elegir y configurar el exploit (como hemos dicho, c√≥digo que permite explotar la vulnerabilidad de un sistema). 
       Confirmar si el objetivo es susceptible al exploit elegido (este paso es opcional). 
       Elegir y configurar el payload (c√≥digo que se ejecuta una vez explotemos la vulnerabilidad). 
       Elegir la t√©cnica de encode o codificaci√≥n para que el payload no sea detectados por los elementos de seguridad del equipo (tambi√©n es opcional aunque recomendable). 
       Ejecutar el exploit. 
       Para la realizaci√≥n de √©stas y otras acciones, metasploit incorpora las siguientes herramientas:
       
       
       msfconsole: l√≠nea de comandos de Metasploit. 
       msfcli: interfaz que permite lanzar un m√≥dulo concreto mediante su configuraci√≥n en la misma ejecuci√≥n de la aplicaci√≥n. 
       msfgui: interfaz gr√°fica de Metasploit. 
       msfd: servicio que queda a la escucha de recibir conexiones para ofrecer una l√≠nea de comandos en remoto. 
       msfbinscan: permite realizar b√∫squedas en ejecutables de instrucciones de salto, instrucciones POP,... 
       msfpescan: permite realizar un an√°lisis sobre DLLs y obtener la direcci√≥n de retorno deseada para que la shellcode se ejecute. 
       msfpayload: permite generar payloads en distintos lenguajes de programaci√≥n, pudiendo embeberlos en ejecutables Windows o binarios de UNIX. 
       msfencode: permite ofuscar el c√≥digo del payload para evitar su detecci√≥n. 
       msfvenom: es la uni√≥n de msfpayload y msfencode. 
       msfupdate: se utiliza para actualizar el framework. 
       
       
       Adem√°s de estas herramientas, metasploit se compone de distintos m√≥dulos. Estos m√≥dulos son:
       
       
       M√≥dulo auxiliary: permite la interacci√≥n de herramientas externas, como pueden ser escaners de vulnerabilidades, sniffers,... 
       M√≥dulo encoders: nos proporciona los diferentes algoritmos para codificar y ofuscar los payloads. 
       M√≥dulo exploits: aqu√≠ se encuentran todos los exploits disponibles en el framework. 
       M√≥dulo payloads: multitud de c√≥digos que se ejecutan una vez tenga √©xito el exploit. 
       M√≥dulo post: funcionalidades para la fase de post explotaci√≥n durante un pentesting. 
       M√≥dulo nops: permite realizar u obtener operaciones nop. 

'''

@bot.message_handler(commands=['crackmapexec'])  
def cme(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, a continuaci√≥n te dejo algo de info sobre CME: \n'.format(user_name) + cme)
    print('crackmapexec')
cme = '''
CrackMapExec o CME es una herramienta dise√±ada para la post-explotaci√≥n, su principal caracter√≠stica es que permite hacer movimientos laterales dentro una red local. Pero tambi√©n tiene muchas opciones de uso, ya que usa m√≥dulos y funcionalidades externas.

Esta escrita en Python y puedes descargarse desde su Github.

CME hace uso de 5 protocolos que son: smb, winrm, ssh, http o mssql. Cada uno de estos protocolos tiene diferentes m√≥dulos de uso, para ver estos m√≥dulos se ejecuta cme con el siguiente parametro:

./cme (protocolo) -L

El protocolo SMB suele ser el m√°s usado ya que la herramienta se desarroll√≥ pensando en entornos Windows y por esto es el que mas m√≥dulos tiene, este adem√°s se usa para poder hacer movimientos laterales, para ello necesitas unas credenciales o un hash NTLM.

Por ejemplo, dispones de unas credenciales para el usuario administrador (qu√© suerte!), con CME puedes sacar la lista de usuarios de una m√°quina Windows con la siguiente instrucci√≥n:

./cme smb 192.168.xx.xx -u administrador -p 123456789 --users

Tambi√©n se pueden hacer b√∫squedas por ficheros dentro del sistema con los par√°metros ‚Äì -pattern y ‚Äì -spider, por ejemplo si queremos buscar ficheros log dentro del sistema, lo haremos con la siguiente instrucci√≥n:

./cme smb 192.168.xx.xx -u administrador -p 123456789 --spider c\$ --pattern log

Otra caracter√≠stica de CME, es que tiene la posibilidad de hacer una consulta a las pol√≠ticas de contrase√±a de la m√°quina que estamos testeando con el par√°metro \'--pass-pol\', la instrucci√≥n ser√≠a:
./cme smb 192.168.xx.xx -u administrador -p 123456789 --pass-pol

Y no pod√≠a faltar una descarga de todas las credenciales de la m√°quina, ya que CrackMapExec es una herramienta para el movimiento lateral, necesitaremos estas credenciales para poder movernos por la red. Podemos usar los modificadores para descargar la SAM, LSA  o NTDS, por ejemplo para descargar la sam:

./cme smb 192.168.xx.xx -u administrador -p 123456789 --sam

Si tenemos un hash NTLM, podremos usarlo para autenticarnos con el modificador -H de esta forma:

./cme smb 192.168.xx.xx -u administrador -H aqui el hash NTLM

Tambi√©n se pueden ejecutar comandos con diferentes t√©cnicas usando el par√°metro -x, por ejemplo podemos ejecutar un ¬´whoami¬ª de la siguiente forma:

./cme smb 192.168.xx.xx -u administrador -p 123456789 -x whoami

Con la ejecuci√≥n de comandos se abren un mont√≥n de posibilidades para meter otras herramientas en escena como pueden ser Empire o Meterpreter.
CrackMapExec es una herramienta muy buena para tareas de pentesting en entornos Microsoft, estos son unos ejemplos b√°sicos de uso, pero la herramienta dispone de un mont√≥n de opciones para ayudar al Pentester.
'''
    

@bot.message_handler(commands=['bettercap'])  
def better(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, aqu√≠ tienes algo de info sobre la herramienta Bettercap o navaja suiza del tr√°fico de red: \n'.format(user_name) + better)
    print('bettercap')
better = '''
        Bettercap es una herramienta muy potente que es compatible con las principales distribuciones basadas en Linux, algunas de sus principales caracter√≠sticas son las siguientes:
        
        Esc√°ner de redes WiFi, permite hacer ataques de desautenticaci√≥n, tambi√©n permite realizar ataques sin clientes a asociaciones PMKID, permite capturar handshakes de clientes que usan protocolo WPA y WPA2.
        Esc√°ner de dispositivos BLE (Bluetooth Low Energ√≠a) para leer y escribir informaci√≥n.
        Esc√°ner de dispositivos inal√°mbricos que usen la banda de 2.4GHz, como los ratones inal√°mbricos, tambi√©n permite realizar ataques MouseJacking con inyecci√≥n de datos.
        Permite hacer ataques pasivos y activos a redes IP
        Permite realizar ataques MitM basados en ARP, DNS y tambi√©n DHCPv6, con el objetivo de capturar toda la informaci√≥n.
        Permite crear un proxy HTTP/HTTPS para levantar el tr√°fico seguro HTTPS, y facilita enormemente el uso de scripts.
        Sniffer de red muy potente para recolecci√≥n de credenciales de usuario.
        Esc√°ner de puertos muy r√°pido
        Tiene una potente API REST para realizar ataques f√°cilmente.
        Incorpora una interfaz gr√°fica de usuario para facilitar los ataques, aunque el terminal de comandos es muy potente.
        Tenemos una gran cantidad de m√≥dulos de diferentes categor√≠as para ampliar funcionalidades
        
        El sniffer incorporado es actualmente capaz de diseccionar e imprimir desde la red (o desde un archivo PCAP previamente capturado) las siguientes informaciones:
        URLs visitadas
        Hosts HTTPS que est√°n siendo visitados
        HTTP POSTed datos
        Autenticaciones HTTP Basic y Digest
        Cookies HTTP.
        Credenciales de FTP
        Credenciales de IRC
        Credenciales POP, IMAP y SMTP
        Credenciales NTLMv1 / v2 (HTTP, SMB, LDAP, etc)
        Credenciales del protocolo DICT
        Credenciales del MPD
        Credenciales NNTP
        Mensajes DHCP y autenticaci√≥n
        Credenciales de inicio de sesi√≥n de REDIS
        Credenciales RLOGIN
        Credenciales SNPP
        
        La instalaci√≥n bajo kali es muy simple y bettercap tambi√©n es compatible con X os, Android, Windows. 
        
        M√≥dulos:
         
        api.rest: m√≥dulo API RESTful
        arp.spoof: m√≥dulo de falsificaci√≥n de arp
        ble.recon: m√≥dulo de descubrimiento de dispositivos Bluetooth de baja energ√≠a
        net.sniff: m√≥dulo de rastreo de red
        dhcp6.spoof: m√≥dulo de falsificaci√≥n de dhcp6 (manipula el servidor DNS del cliente falsificando paquetes DHCP, por lo que debe habilitarse junto con dns.spoof)
        dns.spoof: m√≥dulo de suplantaci√≥n de DNS
        events.stream: m√≥dulo de salida de flujo (es decir, la salida del programa se muestra constantemente en la interfaz del terminal, como la informaci√≥n interceptada por arp)
        wifi: m√≥dulo wifi, con ataque autom√°tico (wifi killer)
'''


@bot.message_handler(commands=['help'])
def send_help(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, "Hola {}, puedes probar con uno de estos comandos:\n /pentest - llama al bot\n /nmap - Listado de comandos de Nmap\n /reverse - Link y pdf para soporte con Reverse Shells\n /puertos - pdf con tabla de puertos comunes\n Info sobre otras herramientas:üëáüèª\n /metasploit\n /sqlmap\n /nuclei\n /bettercap\n /crackmapexec".format(user_name))
    print('help')

user = telebot.TeleBot.get_me
print(user)
print('\n')
update = telebot.TeleBot.get_updates
print(update)

bot.polling()
