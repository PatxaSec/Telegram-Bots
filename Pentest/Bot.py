import telebot, os, random, vt

Token = '<tu token>'
vt_api_key = '<tu api_key>'
chat_id = '<tu chat_id>'


bot = telebot.TeleBot(Token)

# -------Bienvenida
print('bienve')

# Manejar el evento de nuevos miembros en un grupo
@bot.message_handler(func=lambda message: True, content_types=['new_chat_members'])
def welcome_message(message):
    welcome_messages = [
        f'Â¡Bienvenid@ {message.from_user.first_name} a este grupo de hacking Ã©tico! Presentate, Hackea y pasalo genial.',
        f'Â¡Hola {message.from_user.first_name}! Bienvenid@ a este grupo. Estas Hack?',
        f'Â¡Saludos {message.from_user.first_name}! Bienvenid@ a Ã©sta comunidad de Cyber. Si tienes alguna pregunta Ã©tica, no dudes en hacerla.',
        f'{message.from_user.first_name}, sÃ© bienvenid@ al grupo mÃ¡s hack, a disfrutar!']
    random_welcome = random.choice(welcome_messages)
    bot.reply_to(message, random_welcome)


# -------Comandos
print('coman')

@bot.message_handler(commands=['pentest'])  # --Llamada a bot
def init(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, si utilizas /help, podras ver los comandos que tengo disponibles.'.format(user_name))
    print('pingu')

@bot.message_handler(commands=['nmap'])  # --Listado de comandos nmap
def nmap(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, los comandos de nmap son los siguientes: \n \n -->Descubrir sistemas: \n -PS n tcp syn ping \n -PA n ping TCP ACK \n -PU n ping UDP \n -PM Netmask Req \n -PP Timestamp Req \n -PE Echo Req \n -sL anÃ¡lisis de listado \n -PO ping por protocolo \n -PN No hacer ping \n -n no hacer DNS \n -R Resolver DNS en todos los sistemas objetivo \n â€“traceroute: trazar ruta al sistema (para topologÃ­as de red) \n -sP realizar ping, igual que con â€“PP â€“PM â€“PS443 â€“PA80 \n \n -->TÃ©cnicas de anÃ¡lisis de puertos: \n -sS anÃ¡lisis utilizando TCP SYN \n -sT anÃ¡lisis utilizando TCP CONNECT \n -sU anÃ¡lisis utilizando UDP \n -sY anÃ¡lisis utilizando SCTP INIT \n -sZ utilizando COOKIE ECHO de SCTP \n -sO protocolo IP \n -sW ventana TCP -sN \n â€“sF -sX NULL, FIN, XMAS \n â€“sA TCP ACK \n \n -->Puertos a analizar y orden de anÃ¡lisis: \n -p n-mrango \n -pâ€“ todos los puertos \n -p n,m,z especificados \n -p U:n-m,z T:n,m U para UDP, T para TCP \n  -F rÃ¡pido, los 100 comunes \n â€“top-ports n analizar los puertos mÃ¡s utilizados \n -r no aleatorio \n \n -->DuraciÃ³n y ejecuciÃ³n: \n -T0 paranoico \n -T1 sigiloso \n -T2 sofisticado \n -T3 normal \n -T4 agresivo \n -T5 locura \n â€“min-hostgroup \n â€“max-hostgroup \n â€“min-rate \n â€“max-rate \n â€“min-parallelism \n â€“max-parallelism \n â€“min-rtt-timeout \n â€“max-rtt-timeout \n â€“initial-rtt-timeout \n â€“max-retries \n â€“host-timeout â€“scan-delay \n \n -->DetecciÃ³n de servicios y versiones: \n -sV: detecciÃ³n de la versiÃ³n de servicios \n â€“all-ports no excluir puertos \n â€“version-all probar cada exploraciÃ³n \n â€“version-trace rastrear la actividad del anÃ¡lisis de versiÃ³n-O activar detecciÃ³n del S. Operativo \n â€“fuzzy adivinar detecciÃ³n del SO \n â€“max-os-tries establecer nÃºmero mÃ¡ximo de intentos contra el sistema objetivo \n \n -->EvasiÃ³n de Firewalls/IDS: \n -f fragmentar paquetes \n -D d1,d2 encubrir anÃ¡lisis con seÃ±uelos \n -S ip falsear direcciÃ³n origen \n â€“g source falsear puerto origen \n â€“randomize-hosts orden \n â€“spoof-mac <mac> cambiar MAC de origen \n \n -->ParÃ¡metros de nivel de detalle y depuraciÃ³n: \n -v Incrementar el nivel de detalle \n â€“reason motivos por sistema y puerto \n -d (1-9) establecer nivel de depuraciÃ³n \n â€“packet-trace ruta de paquetes \n \n -->Otras opciones: \n â€“resume file continuar anÃ¡lisis abortado (tomando formatos de salida con -oN o -oG) \n -6 activar anÃ¡lisis IPV6 \n -A agresivo, igual que con -O -sV -sC â€“traceroute \n \n -->Opciones interactivas: \n v/V aumentar/disminuir nivel de detalle del anÃ¡lisis \n d/D aumentar/disminuir nivel de depuraciÃ³n \n p/P activar/desactivar traza de paquetes \n \n -->Scripts: \n -sC realizar anÃ¡lisis con los scripts por defecto \n â€“script file ejecutar script (o todos) \n â€“script-args n=v proporcionar argumentos \n â€“script-trace mostrar comunicaciÃ³n entrante y saliente \n \n -->Formatos de salida: \n -oN guardar en formato normal \n -oX guardar en formato XML \n -oG guardar en formato para posteriormente usar Grep(una linea) \n -oA guardar en todos los formatos anteriores'.format(user_name))
    print('nmap')

@bot.message_handler(commands=['reverse'])   #--Reverse-Shell info
def reverse(message):
    print('reverse')
    try:
        # Construye la ruta del archivo .pdf independiente de la plataforma
        pdf_file_path = os.path.join(os.getcwd(), 'Pentest', 'Reverse_Shell.pdf')

        # EnvÃ­a el mensaje de texto como respuesta al comando
        user_name = message.from_user.first_name
        bot.reply_to(message, 'Hola {}, mis sugerencias para realizar una reverse shell las tienes en el siguiente enlace de GitHub o sino, puedes revisar el archivo .pdf que te envÃ­o justo despues: \n'.format(user_name) + '\n' + 'https://github.com/0dayCTF/reverse-shell-generator')

        # EnvÃ­a el archivo .pdf al chat
        with open(pdf_file_path, 'rb') as pdf_file:
            bot.send_document(message.chat.id, pdf_file)

    except Exception as e:
        bot.reply_to(message, "Ha ocurrido un error al enviar el archivo. Por favor, intÃ©ntalo mÃ¡s tarde.")
        print(f"Error: {e}")

# Manejador para el comando /puertos
@bot.message_handler(commands=['puertos'])
def puertos(message):
    print('puertos')
    try:
        # Construye la ruta del archivo .pdf independiente de la plataforma
        pdf_file_path = os.path.join(os.getcwd(), 'Pentest', 'Puertos_comunes.pdf')

        # EnvÃ­a el mensaje de texto como respuesta al comando
        user_name = message.from_user.first_name
        bot.reply_to(message, 'Hola {}, los puertos utilizados mÃ¡s comunes, podrÃ¡s verlos en el siguiente archivo .pdf: \n'.format(user_name))

        # EnvÃ­a el archivo .pdf al chat
        with open(pdf_file_path, 'rb') as pdf_file:
            bot.send_document(message.chat.id, pdf_file)

    except Exception as e:
        bot.reply_to(message, "Ha ocurrido un error al enviar el archivo. Por favor, intÃ©ntalo mÃ¡s tarde.")
        print(f"Error: {e}")
    

@bot.message_handler(commands=['gobuster'])  
def gobuster(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, a enumerar un ratito?? \n'.format(user_name) + gob)
    print('gobuster')
gob = '''
        Gobuster es una herramienta de fuerza bruta muy potente y con el objetivo de enumerar uris en sitios web, es decir, directorios y ficheros, subdominios dns y nombres de host virtuales en servidores web.
        
        Para la enumeraciÃ³n de subdominios dns utilizaremos la palabra clave dir, que como todo comando tiene su propia ayuda:
        
        Usage:
          gobuster dns [flags]
         
        Flags:
          -d, --domain string      The target domain
          -h, --help               help for dns
          -r, --resolver string    Use custom DNS server (format server.com or server.com:port)
          -c, --show-cname         Show CNAME records (cannot be used with '-i' option)
          -i, --show-ips           Show IP addresses
              --timeout duration   DNS resolver timeout (default 1s)
              --wildcard           Force continued operation when wildcard found
         
        Global Flags:
              --delay duration    Time each thread waits between requests (e.g. 1500ms)
              --no-error          Don't display errors
          -z, --no-progress       Don't display progress
          -o, --output string     Output file to write results to (defaults to stdout)
          -p, --pattern string    File containing replacement patterns
          -q, --quiet             Don't print the banner and other noise
          -t, --threads int       Number of concurrent threads (default 10)
          -v, --verbose           Verbose output (errors)
          -w, --wordlist string   Path to the wordlist
        
          Para la enumeraciÃ³n de virtual hosts utilizaremos la palabra clave vhost, que como todo comando tiene su propia ayuda:
        
        Usage:
          gobuster vhost [flags]
         
        Flags:
          -c, --cookies string        Cookies to use for the requests
          -r, --follow-redirect       Follow redirects
          -H, --headers stringArray   Specify HTTP headers, -H 'Header1: val1' -H 'Header2: val2'
          -h, --help                  help for vhost
          -m, --method string         Use the following HTTP method (default "GET")
          -k, --no-tls-validation     Skip TLS certificate verification
          -P, --password string       Password for Basic Auth
              --proxy string          Proxy to use for requests [http(s)://host:port]
              --random-agent          Use a random User-Agent string
              --timeout duration      HTTP Timeout (default 10s)
          -u, --url string            The target URL
          -a, --useragent string      Set the User-Agent string (default "gobuster/3.1.0")
          -U, --username string       Username for Basic Auth
         
        Global Flags:
              --delay duration    Time each thread waits between requests (e.g. 1500ms)
              --no-error          Don't display errors
          -z, --no-progress       Don't display progress
          -o, --output string     Output file to write results to (defaults to stdout)
          -p, --pattern string    File containing replacement patterns
          -q, --quiet             Don't print the banner and other noise
          -t, --threads int       Number of concurrent threads (default 10)
          -v, --verbose           Verbose output (errors)
          -w, --wordlist string   Path to the wordlist
        
        Para la enumeraciÃ³n de buckets S3 utilizaremos la palabra clave s3, que como todo comando tiene su propia ayuda:
         
        Usage:
          gobuster s3 [flags]
         
        Flags:
          -h, --help               help for s3
          -m, --maxfiles int       max files to list when listing buckets (only shown in verbose mode) (default 5)
              --proxy string       Proxy to use for requests [http(s)://host:port]
              --random-agent       Use a random User-Agent string
              --timeout duration   HTTP Timeout (default 10s)
          -a, --useragent string   Set the User-Agent string (default "gobuster/3.1.0")
         
        Global Flags:
              --delay duration    Time each thread waits between requests (e.g. 1500ms)
              --no-error          Don't display errors
          -z, --no-progress       Don't display progress
          -o, --output string     Output file to write results to (defaults to stdout)
          -p, --pattern string    File containing replacement patterns
          -q, --quiet             Don't print the banner and other noise
          -t, --threads int       Number of concurrent threads (default 10)
          -v, --verbose           Verbose output (errors)
          -w, --wordlist string   Path to the wordlist
'''

@bot.message_handler(commands=['sqlmap'])  
def sqlmap(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, su uso es --> \'python sqlmap.py [opciones]\' y las opciones te las dejo a continuaciÃ³n: \n'.format(user_name) + '''
                --url  url  (-u) con la variable vulnerable ejemplo elhacker.net/noticia.php?id=1
                -p (buscar otra variable vunlerable) elhacker.net/noticia.php?id=1&user
                --data si hay un formulario GET,POST los campos vulnerables
                --level=n cinco niveles segÃºn dificultad
                --dbs listar las bases de datos
                --dbms  motor de la base de datos (MySQL,SQL Server ,etc)
                 -D indicamos la base de datos a utilizar (-Database)
                 --tables mostrar las tablas disponibles 
                -t nombre de la tabla --columns
                --dump vuelca resultados, mostrar contenido de las tablas
                -C (Columnas) columnas a mostrar
                --wizard ejecuta un asistente
                 --threads=n nÃºmero de procesos (por defecto 1)
                --delay=n segundos de espera entre peticiones http
                --current-db base de datos que estÃ¡ usando actualmente
                --current-user ver usuario que estÃ¡ ejecutando
                --is-dba â€“current-db ver si el usuario es el dba de la BD
                --privileges ver los privilegios del usuario (alter, create, drop, execute)
                --file-read path (ruta) leer ficheros
                --sql-shell obtener una sql en shell
                --os-shell obtener shell en el servidor (asp es la 1, aspx 2, jsp 3, php 4) (si se poseen los suficientes privilegios y un FPD (Full Path Disclosure)
                 --headers= cabeceras del navegador
                --random-agent cabeceras del navegador aleatorias
                --time-sec= Segundos para retrasar la respuesta de DBMS (por defecto 5)
                ---technique= : Se utiliza para seleccionar la tÃ©cnica que se va a utilizar en la inyecciÃ³n ( B - E - U - S - T - Q.) Boolean-based, Error-based, Union, Stacked querys, Time-based, Inline queries
                --flush-session
                - Si el SQLi es Blind Boolean Based , se especifica con una "B"
                - Si el SQLi es Error Based/Double Query , se especifica con una "E"
                - Si el SQLi es Union Based , se especifica con una "U"
                - Si el SQLi es Stacked querys , se especifica con una "S"
                - Si el SQLi es Time Based , se especifica con una "T"
                - Si el SQLi es Inline queries , se especifica con una "Q"
                --forms si queremos que busque automÃ¡ticamente los campos de formularios
                --proxy= usar servidor proxy 
                --sql-query aÃ±adir consulta sql
                --tamper= scripts ofuscaciÃ³n y bypass (ejemplo space2mysqlblank.py, charencode.py, base64encode.py, randomcomments.py, etc)
                --chek-tor ---> User Tor Anonymity Network
                --tor-port ---> Set Tor proxy port other than default
                --tor-type ---> Set Tor proxy type (HTTP (default ), SOCKS4 or SOCKS5)
                Listado completo  en la documentaciÃ³n oficial:
                 
                 https://github.com/sqlmapproject/sqlmap/wiki/Usage
                 
                 ''')
    print('sqlmap')

@bot.message_handler(commands=['nuclei'])  
def nuclei(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, a continuaciÃ³n te dejo algo de info que espero te ayude: \n'.format(user_name) + nuclei)
    print('nuclei')
nuclei = '''
Nuclei es un escÃ¡ner de vulnerabilidades escrito en Go permitiendo realizar la detecciÃ³n en diferentes protocolos, como por ejemplo; TCP, HTTP, DNS.

La primera vez que se ejecuta la herramienta, lo primero que hace es descargar las plantillas desarrolladas por la comunidad y almacenar dichos ficheros en $HOME/nuclei-templates. A partir de este punto, se puede lanzar la herramienta utilizando cualquiera de las plantillas ya existentes o con una nueva.


Hay varias opciones que son interesantes a la hora de ejecutar la herramienta y simplemente leyendo la ayuda se pueden entender fÃ¡cilmente, sin embargo las mÃ¡s importantes son las siguientes:

-target / -u: Permite indicar una URL sobre la que se van a realizar las pruebas.
-list / -l: Permite indicar un listado de objetivos en un fichero de texto, una URL por cada lÃ­nea en el fichero.
-automatic-scan / -as: Ejecuta un escaneo automÃ¡tico utilizando Wappalyzer para la detecciÃ³n de la arquitectura del objetivo.
-templates / -t: Listado de plantillas o de directorios que contienen plantillas separado por comas.
-tl: Simplemente lista todas las plantillas que detecta nuclei. Si se ejecuta la herramienta sin la opciÃ³n Â«-templatesÂ» enseÃ±arÃ¡ las plantillas de la comunidad que como se ha indicado antes, se encuentran en el directorio $HOME/nuclei-templates.
-validate: Valida las plantillas que se han enviado con la opciÃ³n Â«-templatesÂ» para comprobar que los ficheros YAML se encuentran bien formados.
-et / -exclude-templates: Listado de plantillas o de directorios que contienen plantillas que debe ser ignorado por nuclei separado por comas.
-s / â€“severity: Indica que las plantillas deben ser ejecutadas en funciÃ³n del campo Â«severityÂ» de la plantilla, en donde los posibles valores pueden ser: info, low, medium, high, critical, unknown
-o / -output: Fichero de salida en donde se almacenan los problemas/vulnerabilidades descubiertos por la herramienta.
-sresp / -store-resp: Almacena todas las peticiones y respuestas que ha gestionado nuclei en el directorio indicado con la opciÃ³n Â«-outputÂ».
-silent: No enseÃ±a trazas, solamente los problemas descubiertos.
-config: Permite indicar un fichero de configuraciÃ³n personalizado para modificar el comportamiento por defecto de la herramienta.
-update: Actualizar la herramienta
-up / -update-templates: Actualizar las plantillas de la comunidad a la versiÃ³n mÃ¡s reciente.
-duc / -disable-update-check: Por defecto Nuclei verifica si las plantillas locales se encuentran actualizadas, con esta opciÃ³n se deshabilita este comportamiento.
'''

@bot.message_handler(commands=['metasploit'])  
def metasploit(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, a continuaciÃ³n te dejo algo de info sobre Metasploit: \n'.format(user_name) + info)
    print('metasploit')
info = '''
       Metasploit consta de varias herramientas distintas:

       msfconsole. Consola de Metasploit.
       msfcli. Nos permite ejecutar mÃ³dulos directamente sin entrar en la consola.
       msfpayload. Para generar payloads.
       msfencode. Permite codificar los payloads para quitar null bytes por ejemplo.
       msfvenom. CombinaciÃ³n de msfpayload y msfencode en una sola herramienta.

       Los pasos bÃ¡sicos a seguir para explotar vulnerabilidades usando Metasploit son:


       Elegir y configurar el exploit (como hemos dicho, cÃ³digo que permite explotar la vulnerabilidad de un sistema). 
       Confirmar si el objetivo es susceptible al exploit elegido (este paso es opcional). 
       Elegir y configurar el payload (cÃ³digo que se ejecuta una vez explotemos la vulnerabilidad). 
       Elegir la tÃ©cnica de encode o codificaciÃ³n para que el payload no sea detectados por los elementos de seguridad del equipo (tambiÃ©n es opcional aunque recomendable). 
       Ejecutar el exploit. 
       Para la realizaciÃ³n de Ã©stas y otras acciones, metasploit incorpora las siguientes herramientas:
       
       
       msfconsole: lÃ­nea de comandos de Metasploit. 
       msfcli: interfaz que permite lanzar un mÃ³dulo concreto mediante su configuraciÃ³n en la misma ejecuciÃ³n de la aplicaciÃ³n. 
       msfgui: interfaz grÃ¡fica de Metasploit. 
       msfd: servicio que queda a la escucha de recibir conexiones para ofrecer una lÃ­nea de comandos en remoto. 
       msfbinscan: permite realizar bÃºsquedas en ejecutables de instrucciones de salto, instrucciones POP,... 
       msfpescan: permite realizar un anÃ¡lisis sobre DLLs y obtener la direcciÃ³n de retorno deseada para que la shellcode se ejecute. 
       msfpayload: permite generar payloads en distintos lenguajes de programaciÃ³n, pudiendo embeberlos en ejecutables Windows o binarios de UNIX. 
       msfencode: permite ofuscar el cÃ³digo del payload para evitar su detecciÃ³n. 
       msfvenom: es la uniÃ³n de msfpayload y msfencode. 
       msfupdate: se utiliza para actualizar el framework. 
       
       
       AdemÃ¡s de estas herramientas, metasploit se compone de distintos mÃ³dulos. Estos mÃ³dulos son:
       
       
       MÃ³dulo auxiliary: permite la interacciÃ³n de herramientas externas, como pueden ser escaners de vulnerabilidades, sniffers,... 
       MÃ³dulo encoders: nos proporciona los diferentes algoritmos para codificar y ofuscar los payloads. 
       MÃ³dulo exploits: aquÃ­ se encuentran todos los exploits disponibles en el framework. 
       MÃ³dulo payloads: multitud de cÃ³digos que se ejecutan una vez tenga Ã©xito el exploit. 
       MÃ³dulo post: funcionalidades para la fase de post explotaciÃ³n durante un pentesting. 
       MÃ³dulo nops: permite realizar u obtener operaciones nop. 

'''

@bot.message_handler(commands=['crackmapexec'])  
def cme(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, a continuaciÃ³n te dejo algo de info sobre CME: \n'.format(user_name) + cme)
    print('crackmapexec')
cme = '''
CrackMapExec o CME es una herramienta diseÃ±ada para la post-explotaciÃ³n, su principal caracterÃ­stica es que permite hacer movimientos laterales dentro una red local. Pero tambiÃ©n tiene muchas opciones de uso, ya que usa mÃ³dulos y funcionalidades externas.

Esta escrita en Python y puedes descargarse desde su Github.

CME hace uso de 5 protocolos que son: smb, winrm, ssh, http o mssql. Cada uno de estos protocolos tiene diferentes mÃ³dulos de uso, para ver estos mÃ³dulos se ejecuta cme con el siguiente parametro:

./cme (protocolo) -L

El protocolo SMB suele ser el mÃ¡s usado ya que la herramienta se desarrollÃ³ pensando en entornos Windows y por esto es el que mas mÃ³dulos tiene, este ademÃ¡s se usa para poder hacer movimientos laterales, para ello necesitas unas credenciales o un hash NTLM.

Por ejemplo, dispones de unas credenciales para el usuario administrador (quÃ© suerte!), con CME puedes sacar la lista de usuarios de una mÃ¡quina Windows con la siguiente instrucciÃ³n:

./cme smb 192.168.xx.xx -u administrador -p 123456789 --users

TambiÃ©n se pueden hacer bÃºsquedas por ficheros dentro del sistema con los parÃ¡metros â€“ -pattern y â€“ -spider, por ejemplo si queremos buscar ficheros log dentro del sistema, lo haremos con la siguiente instrucciÃ³n:

./cme smb 192.168.xx.xx -u administrador -p 123456789 --spider c\$ --pattern log

Otra caracterÃ­stica de CME, es que tiene la posibilidad de hacer una consulta a las polÃ­ticas de contraseÃ±a de la mÃ¡quina que estamos testeando con el parÃ¡metro \'--pass-pol\', la instrucciÃ³n serÃ­a:
./cme smb 192.168.xx.xx -u administrador -p 123456789 --pass-pol

Y no podÃ­a faltar una descarga de todas las credenciales de la mÃ¡quina, ya que CrackMapExec es una herramienta para el movimiento lateral, necesitaremos estas credenciales para poder movernos por la red. Podemos usar los modificadores para descargar la SAM, LSA  o NTDS, por ejemplo para descargar la sam:

./cme smb 192.168.xx.xx -u administrador -p 123456789 --sam

Si tenemos un hash NTLM, podremos usarlo para autenticarnos con el modificador -H de esta forma:

./cme smb 192.168.xx.xx -u administrador -H aqui el hash NTLM

TambiÃ©n se pueden ejecutar comandos con diferentes tÃ©cnicas usando el parÃ¡metro -x, por ejemplo podemos ejecutar un Â«whoamiÂ» de la siguiente forma:

./cme smb 192.168.xx.xx -u administrador -p 123456789 -x whoami

Con la ejecuciÃ³n de comandos se abren un montÃ³n de posibilidades para meter otras herramientas en escena como pueden ser Empire o Meterpreter.
CrackMapExec es una herramienta muy buena para tareas de pentesting en entornos Microsoft, estos son unos ejemplos bÃ¡sicos de uso, pero la herramienta dispone de un montÃ³n de opciones para ayudar al Pentester.
'''
    

@bot.message_handler(commands=['bettercap'])  
def better(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, aquÃ­ tienes algo de info sobre la herramienta Bettercap o navaja suiza del trÃ¡fico de red: \n'.format(user_name) + better)
    print('bettercap')
better = '''
        Bettercap es una herramienta muy potente que es compatible con las principales distribuciones basadas en Linux, algunas de sus principales caracterÃ­sticas son las siguientes:
        
        EscÃ¡ner de redes WiFi, permite hacer ataques de desautenticaciÃ³n, tambiÃ©n permite realizar ataques sin clientes a asociaciones PMKID, permite capturar handshakes de clientes que usan protocolo WPA y WPA2.
        EscÃ¡ner de dispositivos BLE (Bluetooth Low EnergÃ­a) para leer y escribir informaciÃ³n.
        EscÃ¡ner de dispositivos inalÃ¡mbricos que usen la banda de 2.4GHz, como los ratones inalÃ¡mbricos, tambiÃ©n permite realizar ataques MouseJacking con inyecciÃ³n de datos.
        Permite hacer ataques pasivos y activos a redes IP
        Permite realizar ataques MitM basados en ARP, DNS y tambiÃ©n DHCPv6, con el objetivo de capturar toda la informaciÃ³n.
        Permite crear un proxy HTTP/HTTPS para levantar el trÃ¡fico seguro HTTPS, y facilita enormemente el uso de scripts.
        Sniffer de red muy potente para recolecciÃ³n de credenciales de usuario.
        EscÃ¡ner de puertos muy rÃ¡pido
        Tiene una potente API REST para realizar ataques fÃ¡cilmente.
        Incorpora una interfaz grÃ¡fica de usuario para facilitar los ataques, aunque el terminal de comandos es muy potente.
        Tenemos una gran cantidad de mÃ³dulos de diferentes categorÃ­as para ampliar funcionalidades
        
        El sniffer incorporado es actualmente capaz de diseccionar e imprimir desde la red (o desde un archivo PCAP previamente capturado) las siguientes informaciones:
        URLs visitadas
        Hosts HTTPS que estÃ¡n siendo visitados
        HTTP POSTed datos
        Autenticaciones HTTP Basic y Digest
        Cookies HTTP.
        Credenciales de FTP
        Credenciales de IRC
        Credenciales POP, IMAP y SMTP
        Credenciales NTLMv1 / v2 (HTTP, SMB, LDAP, etc)
        Credenciales del protocolo DICT
        Credenciales del MPD
        Credenciales NNTP
        Mensajes DHCP y autenticaciÃ³n
        Credenciales de inicio de sesiÃ³n de REDIS
        Credenciales RLOGIN
        Credenciales SNPP
        
        La instalaciÃ³n bajo kali es muy simple y bettercap tambiÃ©n es compatible con X os, Android, Windows. 
        
        MÃ³dulos:
         
        api.rest: mÃ³dulo API RESTful
        arp.spoof: mÃ³dulo de falsificaciÃ³n de arp
        ble.recon: mÃ³dulo de descubrimiento de dispositivos Bluetooth de baja energÃ­a
        net.sniff: mÃ³dulo de rastreo de red
        dhcp6.spoof: mÃ³dulo de falsificaciÃ³n de dhcp6 (manipula el servidor DNS del cliente falsificando paquetes DHCP, por lo que debe habilitarse junto con dns.spoof)
        dns.spoof: mÃ³dulo de suplantaciÃ³n de DNS
        events.stream: mÃ³dulo de salida de flujo (es decir, la salida del programa se muestra constantemente en la interfaz del terminal, como la informaciÃ³n interceptada por arp)
        wifi: mÃ³dulo wifi, con ataque automÃ¡tico (wifi killer)
'''


@bot.message_handler(commands=['help'])
def send_help(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, "Hola {}, puedes enviar un archivo para que lo analice VirusTotal o probar con uno de estos comandos:\n /pentest - llama al bot\n /nmap - Listado de comandos de Nmap\n /reverse - Link y pdf para soporte con Reverse Shells\n /puertos - pdf con tabla de puertos comunes\n Info sobre otras herramientas:ðŸ‘‡ðŸ»\n /metasploit\n /sqlmap\n /nuclei\n /bettercap\n /crackmapexec".format(user_name))
    print('help')


# -------VirusTotal
print('vt')

vt_client = vt.Client(vt_api_key)

# FunciÃ³n para escanear un archivo con VirusTotal
def scan_file(file_path):
    try:
        with open(file_path, "rb") as file:
            response = vt_client.scan_file(file)
            response_result = response.get("data", {}).get("attributes", {}).get("last_analysis_stats", {})
            return response_result
    except Exception as e:
        print("Error en el escaneo del archivo:", e)

# Manejador para mensajes de archivos
@bot.message_handler(content_types=["document"])
def handle_file(message):
    file_id = message.document.file_id
    file_info = bot.get_file(file_id)
    file_path = file_info.file_path
    downloaded_file = bot.download_file(file_path)

    # Guarda el archivo descargado
    file_name = "nombre_archivo.extension"  # Puedes guardar el archivo con un nombre especÃ­fico si lo deseas
    with open(file_name, "wb") as new_file:
        new_file.write(downloaded_file)

    # Escanea el archivo con VirusTotal
    scan_result = scan_file(file_name)

    # Elimina el archivo descargado
    os.remove(file_name)

    if scan_result.get("malicious", 0) > 0:  # Archivo malicioso
        bot.reply_to(message, "Â¡Cuidado! Este archivo es malicioso y ha sido eliminado.")
        # Borra el archivo malicioso en el chat
        bot.delete_message(message.chat.id, message.message_id)
        # Puedes agregar aquÃ­ acciones adicionales, como bloquear al usuario o tomar otras medidas de seguridad
    else:  # Archivo seguro
        bot.reply_to(message, "Todo correcto, puedes abrir el archivo sin problemas.")



user = telebot.TeleBot.get_me
print(user)
print('\n')
update = telebot.TeleBot.get_updates
print(update)

bot.polling()
